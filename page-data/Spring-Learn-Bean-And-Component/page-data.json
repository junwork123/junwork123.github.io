{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Spring-Learn-Bean-And-Component/",
    "result": {"data":{"cur":{"id":"d33978b6-42dc-5f40-970b-156814129346","html":"<p>지적과 댓글은 언제나 환영합니다!</p>\n<p><br/><br/></p>\n<p>Spring으로 개발을 하다보면 @Bean과 @Component를 언제 써야할지 헷갈릴때가 있다.</p>\n<p>둘다 Bean을 생성할때 사용하는 어노테이션인데 왜 2개로 나누어져있을까?</p>\n<br>\n<hr>\n<h2 id=\"bean의-정의와-용도\" style=\"position:relative;\"><a href=\"#bean%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%9A%A9%EB%8F%84\" aria-label=\"bean의 정의와 용도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Bean의 정의와 용도</h2>\n<br>\n<p>@Bean의 용도를 한줄로 요약하자면,</p>\n<p>개발자가 컨트롤이 불가능한 <code class=\"language-text\">외부 라이브러리들을 Bean으로 등록</code>하고 싶은 경우에 사용된다.</p>\n<br>\n<p><code class=\"language-text\">Bean.java</code>의 documentation을 보면, 아래와 같은 문장이 가장 처음써있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Indicates that a method produces a bean to be managed by the Spring container.</code></pre></div>\n<p>그렇다.</p>\n<p>스프링 컨테이너에 의해 관리되는 Bean들을 생성하는 <code class=\"language-text\">method</code>에 사용할 수 있는 어노테이션이다.</p>\n<br>\n<p>실제 정의를 살펴보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span>METHOD<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span>ANNOTATION_TYPE<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Documented</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">Bean</span> <span class=\"token punctuation\">{</span></code></pre></div>\n<br>\n<p>타겟에 <code class=\"language-text\">method</code>에만 적용할 수 있도록 명시되어 있다.</p>\n<p>떄문에 직접 작성한 <code class=\"language-text\">class</code>에는 사용할 수 없는 것이다.</p>\n<br>\n<p>그렇기 때문에 외부 라이브러리를 bean으로 사용하고 싶을 때 <code class=\"language-text\">@Configuration</code> 클래스 안에 <code class=\"language-text\">@bean</code>을 사용하여 생성 메소드를 작성하는 것이다.</p>\n<p><br><br></p>\n<p>그렇다면 <code class=\"language-text\">class</code>에도 사용할 수 있는 어노테이션이 있지 않을까?</p>\n<p><code class=\"language-text\">@Component</code>가 바로 그렇다.</p>\n<br>\n<hr>\n<h2 id=\"component\" style=\"position:relative;\"><a href=\"#component\" aria-label=\"component permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Component</h2>\n<br>\n<p><code class=\"language-text\">@Component</code>는 <code class=\"language-text\">class</code>를 bean으로 사용할 수 있도록 해주는 어노테이션이다.</p>\n<p>아래는 <code class=\"language-text\">Component.java</code>에 나오는 원문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Indicates that an annotated class is a \"component\". Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.\nOther class-level annotations may be considered as identifying a component as well, typically a special kind of component: e.g. the @Repository annotation or AspectJ's @Aspect annotation.</code></pre></div>\n<br>\n<p>해석하자면, <u>어노테이션 기반의 configuration에 후보로 등록</u>되도록 해준다.</p>\n<p>또한 다른 클래스 레벨의 어노테이션(ex : <code class=\"language-text\">@Controller</code>, <code class=\"language-text\">@Repository</code>, <code class=\"language-text\">@Service</code>)도 그런 역할을 할 수 있도록 해준다.</p>\n<p>우리가 Spring을 공부하며 배운 내용 그대로가 적혀있다.</p>\n<br>\n<p>실제 정의를 살펴보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span>TYPE<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Documented</span>\n<span class=\"token annotation punctuation\">@Indexed</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span></code></pre></div>\n<br>\n<p>class에 적용할 수 있도록 타겟이 <code class=\"language-text\">TYPE</code> 형태로 지정되어 있다.</p>\n<p>따라서 직접 만든 클래스에 사용이 가능하다.</p>\n<br>\n<p>다만, <code class=\"language-text\">@Bean</code>과 차이점으로 <code class=\"language-text\">@Indexed</code>라는 어노테이션이 설정되어 있는 것을 볼 수있다.</p>\n<br>\n<p><code class=\"language-text\">@Indexed</code>는 <code class=\"language-text\">@Component</code>어노테이션과 같이 사용되는데, 컴파일 시점에 <code class=\"language-text\">@Component</code> 어노테이션이 검색될 수 있도록 완전정규화된 이름을 부여해주는 역할을 한다.</p>\n<details>\n    <summary>원문 참조</summary>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">The CandidateComponentsIndex is an alternative to classpath scanning that uses a metadata file generated at compilation time. The index allows retrieving the candidate components (i.e. fully qualified name) based on a stereotype. This annotation instructs the generator to index the element on which the annotated element is present or if it implements or extends from the annotated element. The stereotype is the fully qualified name of the annotated element.\n\nConsider the default Component annotation that is meta-annotated with this annotation. If a component is annotated with Component, an entry for that component will be added to the index using the org.springframework.stereotype.Component stereotype.</code></pre></div>\n</details>\n<br>\n<hr>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며..</h2>\n<br>\n<p>자, 이제 <code class=\"language-text\">@Bean</code>과 <code class=\"language-text\">@Component</code>의 차이점에 대해 설명할 수 있는가?</p>\n<p>용도에 맞는 어노테이션 사용도 중요하지만,</p>\n<p>정의를 직접 찾아보고 해석해보는 것도 좋은 경험이 될 것이다.</p>\n<br/>\n<h2 id=\"불변\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80\" aria-label=\"불변 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>불변</strong></h2>\n<p><em>출처</em></p>\n<p><em><a href=\"https://jojoldu.tistory.com/27\">jojoldu님 블로그</a></em></p>\n<p><em><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1#\">인프런 스프링 MVC 강의 1편</a></em></p>\n<p><em><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/\">인프런 스프링 핵심 원리 기본편</a></em></p>\n<br/>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#bean%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%9A%A9%EB%8F%84\">@Bean의 정의와 용도</a></li>\n<li><a href=\"#component\">@Component</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며..</a></li>\n<li><a href=\"#%EB%B6%88%EB%B3%80\"><strong>불변</strong></a></li>\n</ul>\n</div>","excerpt":"지적과 댓글은 언제나 환영합니다!  Spring으로 개발을 하다보면 @Bean과 @Component를 언제 써야할지 헷갈릴때가 있다. 둘다 Bean을 생성할때 사용하는 어노테이션인데 왜 2개로 나누어져있을까? @Bean의 정의와 용도 @Bean의 용도를 한줄로 요약하자면, 개발자가 컨트롤이 불가능한 하고 싶은 경우에 사용된다. 의 documentation을 보면, 아래와 같은 문장이 가장 처음써있다. 그렇다. 스프링 컨테이너에 의해 관리되는 Bean들을 생성하는 에 사용할 수 있는 어노테이션이다. 실제 정의를 살펴보면 다음과 같다. 타겟에 에만 적용할 수 있도록 명시되어 있다. 떄문에 직접 작성한 에는 사용할 수 없는 것이다. 그렇기 때문에 외부 라이브러리를 bean으로 사용하고 싶을 때  클래스 안에 을 사용하여 생성 메소드를 작성하는 것이다.  그렇다면 에도 사용할 수 있는 어노테이션이 있지 않을까? 가 바로 그렇다. @Component 는 를 bean으로 사용할 수 있도록 해…","frontmatter":{"date":"September 19, 2022","title":"스프링 @Bean과 @Component의 차이점을 아시나요?","categories":"Spring","author":"주녁","emoji":"🔮"},"fields":{"slug":"/Spring-Learn-Bean-And-Component/"}},"next":{"id":"2ba196fa-1dd0-5125-b54d-32e0d611cbce","html":"<p>지적과 댓글은 언제나 환영합니다!</p>\n<p><br/><br/></p>\n<h1 id=\"들어가기에-앞서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\" aria-label=\"들어가기에 앞서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기에 앞서</h1>\n<br>\n<p><code class=\"language-text\">프로세스(Process)</code>와 <code class=\"language-text\">쓰레드(Thread)</code>의 차이를 설명하기에 앞서</p>\n<p><code class=\"language-text\">프로그램(Program)</code>의 정의를 짚고 넘어가자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">어떤 문제를 해결하기 위해 컴퓨터에게 주어지는 \n처리 방법과 순서를 기술한 일련의 명령문의 집합체.\n(국어표준대사전)</code></pre></div>\n<br>\n<p>그렇다. 프로그램은 <u>명령문의 집합체</u>이다.</p>\n<p>코드의 덩어리일뿐 아직 실행되지 않은 상태이다.</p>\n<p>이 상태를 <code class=\"language-text\">정적(static)인 상태</code>라고 한다.</p>\n<br>\n<p>반대로, <code class=\"language-text\">동적(Dynamic)인 상태</code>도 있다.</p>\n<p>실행시, 메모리에 <code class=\"language-text\">프로그램</code>이 적재되는 것을 동적인 상태라고 한다.</p>\n<p>그리고 이렇게 <u>동적인 상태에 있는 프로그램</u>을 <code class=\"language-text\">*프로세스</code>라고 한다.</p>\n<p>*<em>P.S 스케줄러 입장에서는 <code class=\"language-text\">작업(task)</code>라고 부르기도 한다.</em></p>\n<br/>\n<hr>\n<h2 id=\"운영체제와-프로세스\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"운영체제와 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>운영체제와 프로세스</strong></h2>\n<br/>\n<p><code class=\"language-text\">프로세스</code>는 프로그램이 메모리에 올라가 있는 상태이다.</p>\n<br>\n프로그램이 메모리에 올라갈 때, \n<p>운영체제는 <code class=\"language-text\">PCB</code>(Process Control Block)라는</p>\n<p>자료구조를 통해 프로세스를 제어한다.</p>\n<br>\n<p>운영체제는 하나의 CPU로 여러 개의 프로세스를 구동하기 위해,</p>\n<p><u>일정한 CPU 시간 만큼 할당하여 여러 프로세스를 실행</u>하는</p>\n<p><code class=\"language-text\">시분할 방식</code>을 사용한다.</p>\n<br>\n<p>이 때 <u>프로세스를 전환하는 작업</u>을 <code class=\"language-text\">Context Switching</code>이라고 하고,</p>\n<p><code class=\"language-text\">PCB</code>를 통해 상태를 저장하고 불러온다.</p>\n<br>\n<hr>\n<h2 id=\"점점-더-커지는-프로그램의-크기\" style=\"position:relative;\"><a href=\"#%EC%A0%90%EC%A0%90-%EB%8D%94-%EC%BB%A4%EC%A7%80%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%ED%81%AC%EA%B8%B0\" aria-label=\"점점 더 커지는 프로그램의 크기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>점점 더 커지는 프로그램의 크기</h2>\n<br>\n<p>여기서 문제가 발생한다.</p>\n<p><u>100만번의 요청을 프로세스 혼자 감당할 수 있을까?</u></p>\n<br>\n<p>혹시, <u>프로세스를 여러개로 늘리면 되지 않을까?</u></p>\n<p>하는 생각을 했는가?</p>\n<br>\n<p>아쉽지만, 운영체제는 안정성을 위해서</p>\n<p><u>프로세스에게 할당된 메모리에만 접근</u> 하도록</p>\n<p><code class=\"language-text\">제약</code>을 두기 때문에 불가능한 일이다.</p>\n<br>\n<p>이러한 문제를 해결하기 위해 만들어진 개념이 있다.</p>\n<p><u>프로세스의 메모리를 공유하는 더 작은 실행 단위</u>, <code class=\"language-text\">쓰레드(Thread)</code>이다.</p>\n<br>\n<hr>\n<h2 id=\"쓰레드의-특징\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"쓰레드의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>쓰레드의 특징</strong></h2>\n<br>\n<h3 id=\"응답성-향상\" style=\"position:relative;\"><a href=\"#%EC%9D%91%EB%8B%B5%EC%84%B1-%ED%96%A5%EC%83%81\" aria-label=\"응답성 향상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>응답성 향상</strong></h3>\n<p>프로세스는 하나 이상의 쓰레드를 갖는다.</p>\n<p>따라서, 어느 한 쓰레드가 대기중이어도</p>\n<p>다른 쓰레드들은 작업을 계속 진행할 수 있다.</p>\n<br>\n<h3 id=\"자원-공유\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0\" aria-label=\"자원 공유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>자원 공유</strong></h3>\n<p>또한, 같은 프로세스 내의 쓰레드는 <u><code class=\"language-text\">Heap</code> 영역 내의 메모리를 공유</u>한다.</p>\n<p><em>*<code class=\"language-text\">Stack</code> 영역의 메모리는 각자 사용한다.</em></p>\n<p>때문에, <code class=\"language-text\">Context Switching</code> 비용이</p>\n<p>멀티 프로세스 환경보다 상대적으로 저렴하다.</p>\n<br>\n<p>쓰레드는 탁월한 기능을 가지고 있지만,</p>\n<p>그만큼 주의할 점도 있다.</p>\n<p>한 쓰레드가 문제가 생기면, 전체 프로세스에 영향을 준다.</p>\n<p>그리고 같은 데이터에 접근할 때 생기는 <code class=\"language-text\">*동시성 문제</code>이다.</p>\n<p><em>*이 문제는 다음 포스팅을 통해 확인하자.</em></p>\n<p><br/><br/></p>\n<h2 id=\"마무리하며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0\" aria-label=\"마무리하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>마무리하며..</strong></h2>\n<p>자, 이제 프로세스와 쓰레드의 차이를 설명할 수 있는가?</p>\n<p>조금 더 공부가 필요하다면,</p>\n<p>Interner Explorer와 Chrome의 동작방식에 대해 찾아보자.</p>\n<br>\n<p><em>출처</em></p>\n<p><em><a href=\"https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4\">raejoonee님 블로그</a></em></p>\n<p><em><a href=\"https://brunch.co.kr/@kd4/3\">kd4님 블로그</a></em></p>\n<p><em><a href=\"https://preamtree.tistory.com/10\">preamtree님 블로그</a></em></p>\n<br/>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\"><strong>운영체제와 프로세스</strong></a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%90%EC%A0%90-%EB%8D%94-%EC%BB%A4%EC%A7%80%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%ED%81%AC%EA%B8%B0\">점점 더 커지는 프로그램의 크기</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\"><strong>쓰레드의 특징</strong></a></p>\n<ul>\n<li><a href=\"#%EC%9D%91%EB%8B%B5%EC%84%B1-%ED%96%A5%EC%83%81\"><strong>응답성 향상</strong></a></li>\n<li><a href=\"#%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0\"><strong>자원 공유</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0\"><strong>마무리하며..</strong></a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 19, 2022","title":"프로세스(Process)와 쓰레드(Thread)의 차이를 아시나요?","categories":"knowledge","author":"주녁","emoji":"🔮"},"fields":{"slug":"/knowledge-about-Process-and-Thread/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.junwork.net","comments":{"utterances":{"repo":"junwork123/blog-comments"}}}}},"pageContext":{"slug":"/Spring-Learn-Bean-And-Component/","nextSlug":"/knowledge-about-Process-and-Thread/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}