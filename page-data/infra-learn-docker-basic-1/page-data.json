{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/infra-learn-docker-basic-1/",
    "result": {"data":{"cur":{"id":"35782ec5-7ab5-5df6-9036-174896f07329","html":"<p>지적과 댓글은 언제나 환영합니다!</p>\n<br>\n<p>이 글은 3편의 시리즈물로 제작하였다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">개념편</code> : Docker의 개념</p>\n</li>\n<li>\n<p><code class=\"language-text\">실습편</code> : Spring Boot 앱을 Docker로 배포하기</p>\n</li>\n<li>\n<p><code class=\"language-text\">심화편</code> : Docker 공식문서 같이읽기</p>\n</li>\n</ul>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEmUlEQVQ4yz3Ue0xTdxQH8J/KzP5Ylv3B9K8l+3NZFml7W27b2xZCRSq20Odt7y2gzLopoDwUEC2rPKSl3NsHbj7ZlmoiOmZiomE4N4yPPZzPKg6GUwE3wcVCS3sL1LZnARJPvjnnr0/OHyc5aCaSXk4onOLi8Cq0EPzz8d2hkcmXHBeHWBzicYhEYCacjs5CNJaeDqfeELQ8psMpjoMrv/9a49+ymcnfzOZX+Eyn+gN/PZk8//NF+/G6Sg/dfHzPrQcPOA7eeLS0Mzk3BxcG+/UO3MRkm1x4USumav5YfYBnbS3Utgj1bszswfVuvo3VPns+FeMgNJNcxKFwMsbBvUej9EEl7SGK7SJto9Tm1Nd9WW5za/N2fVK0Hze2yTY28QsaePiOD7rPeKIxmI2lpsMpNB1JJhLQEfhC7xZoO/jbnIbg8N2x8WdNTXtZn/v7gd7iHXnq/Zj92M7+6+cvXD137Ez3qXMnHw4/jcUBhWfT5y/3Ww7m0G5F2zd7xv8dBwCGYRBCa95f811v34vJf2paPg9NhwAg8O0pg87440+X7t0PTr7kUKA/UFDLIzslZa4Nt+/ehqUaGBjIzMxECPV83QMAo6Ojs7OzAJCbk4sQ0ul0C/Pzj4afImtHHumSWBkFyYpKHIUjIyPLfmxs7P79e8nkawCYmpqKRMIAEAwGaZo+e/YspNMPh/5GJjdOe2QUS5R45aZOkXGfwhdw3g7eTCQSADA/txCLRi8PXgqHF3E6nQaA+Bz3x607U/9xaFnSHoJkpUZGRvsJzYEsdRNW3lLc4P+svttWwZJki+Jon/fGrWu/3fll4MrF0329w48nojFAFEPQDGH2ECXbsTodz9AsKT2cW+qVmTqzde2YwYWbWZz2EpvsWRtrRMVN4vy6db0/nEksLJ4aUZ7FtUZW2mjinywW7tZk6etFBg9B+eWlPrmVkdGMjGKIEp/c6pXRXhnllVpd64eePItxgIoaJIYWQtcmsWwVuFU8V0FW+yZeFc2najGdU0L65KRXRvqIxb4Uc7dC0yYI9B3nOEAbdoqK6vDCarGqQUJZeV1qPqviMSpee0HWXhO/wYbvrJTaasWb6yVljdJP6yTVVcQBcl2gfvt0BJCxTW5sFauqsw0Oma5daq7P3kXyWS3mUfMPbRT0qIUn1MJjGuHhYuFXWuERbXaPRujXCLY3F/VfH0Skk7CwCgtD6B0STbXYwsoNjFTXiJdW4TWV4oatInuZyEGL2i14hwV3GkVdZnHtVrH96O7hJxNoQwVR5sdoVm7pIkytkqJ6salFbj2kMPtzSL/CwMqNXTKyS2rpFFFtWKkD0+8XHOnriXMQ5dLonZygwFJbymTTXsLql1MeqW6fgOrAzE6hxSmkXELKxbe0rldVVmJl+6Q7dn+oOz1448VCAl5NJ9GKfFiBv+BRDrI9x+KSau25mLlcUl5F2GzENhu+peIjg2ut8krm+gmUBygXVufNXbv5fG4eQjMptEr5+m3Z45UK7l3l0Fr11fcU1zMkz1flQ4YymaFMrsxLISVkEBNvKV6tLkisUCbXFo4/HZ+JLv2T/wH+HYyivtY6fAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Let&#39;s go\"\n        title=\"Let&#39;s go\"\n        src=\"/static/8b60ca2f77749f5ca571278d5e90b09b/5a46d/0.png\"\n        srcset=\"/static/8b60ca2f77749f5ca571278d5e90b09b/e9ff0/0.png 180w,\n/static/8b60ca2f77749f5ca571278d5e90b09b/5a46d/0.png 300w\"\n        sizes=\"(max-width: 300px) 100vw, 300px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><u><strong>시작해보자!</strong></u></p>\n<hr>\n<h2 id=\"도커docker와-컨테이너container\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EC%BB%A4docker%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88container\" aria-label=\"도커docker와 컨테이너container permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>도커(Docker)와 컨테이너(Container)</strong></h2>\n<br>\n<h3 id=\"도커docker란\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EC%BB%A4docker%EB%9E%80\" aria-label=\"도커docker란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>도커(Docker)란?</strong></h3>\n<p>도커는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해</p>\n<p><u>컨테이너(Container)</u>로 실행하고 관리하는 오픈소스 프로젝트이다.</p>\n<br>\n<h3 id=\"u컨테이너containeru란\" style=\"position:relative;\"><a href=\"#u%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88containeru%EB%9E%80\" aria-label=\"u컨테이너containeru란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong><u>컨테이너(Container)</u>란?</strong></h3>\n<p>컨테이너는 격리된 공간에서 프로세스가 작동하는 기술이다.</p>\n<p>여기에는 <u>코드, 런타임, 시스템 도구, 시스템 라이브러리 등</u> 서버에 설치되는 무엇이든 포함될 수 있다.</p>\n<p>이는 <u><strong>실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증</strong></u>한다.</p>\n<br>\n<hr>\n<h2 id=\"기존-vmvirtual-machine과-컨테이너는-무슨-차이일까\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4-vmvirtual-machine%EA%B3%BC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EC%9D%BC%EA%B9%8C\" aria-label=\"기존 vmvirtual machine과 컨테이너는 무슨 차이일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>기존 VM(Virtual Machine)과 컨테이너는 무슨 차이일까?</strong></h2>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAChUlEQVQoz3WN209ScQDHzx/S1urZ9eSrk8guW17mmPdSZ15IDFFRCiONVAQFtkK5yF0RuagIIjALATUUUFAmim1Ou9pQ0+WBwwHOr7WeevC7zz6Pny+0f7Li+6LfOF6Ifw+kQ/pU2JA6CMTtU/CcFI34AAAAy4ArBjk+8UXrFYow5SwoS6rLEtpyxCk9fV4ea8iBZ8QAgEwaxQCGgX/6D8h5IBzzVWsj3ecRAzpDQizkpHfq7FXtCSkPtqr/9tPpK5/Ne/0DrhxRsOFsQ4KM5sbl9xPOsVg97rjo5qVOgAGAJC+S6Xgmg2IojKGXIJ3EkDgG/8aQOGSNDvGX86VbLacbkoQ0Hx4vSjilMXLhj4pbqEkVTYQMW936XebRkSO12H+5QEOC+nM5+3S49VzWD1n3B9nLOEmYeBGSpkS4pOIe6pb9IubFim+kZxR78NqE/7Em/PTb4SwwtWR0VSAgT/Da4I6HCI8M+bbXrO45x6rD510JeuybHvu6x+2dt7iM+lh01/LzomR5u2490rX5lendY3ojPf7P7Yu7z6yh1+4oZLK6BBKdUmNWTllURptSb1NozXLdPEek8Qd3VncOO0UmptrO0S1yp11c4xLX6OyddNDVtuFZF8TkSQj1ndVkBrFrgMIYau1mN1H7aloY+ZVkg/m944OH8IhUR3rR3N5LY7CpdBalq6+OSKtpoFLpLOhJ+5ssXNnd0ubbhKZyIr20kYYnEHOLG69nFwiVxolp27XsgjulJHwJqbC2o5LEwJc05xKIWfjKB1UUSKado7NG+eJJzohqWDg+NDo++E7JFqjaevnOFf/HwHZbD58rmuCJNWyBiifWsN4qOCOql2whV6z5A/+qxe086EsPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VM(왼쪽)과 Docker(오른쪽)의 구성도\"\n        title=\"VM(왼쪽)과 Docker(오른쪽)의 구성도\"\n        src=\"/static/4b22177f4aadf8792b692ae795c140eb/37523/1.png\"\n        srcset=\"/static/4b22177f4aadf8792b692ae795c140eb/e9ff0/1.png 180w,\n/static/4b22177f4aadf8792b692ae795c140eb/f21e7/1.png 360w,\n/static/4b22177f4aadf8792b692ae795c140eb/37523/1.png 720w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>VM(왼쪽)과 Docker(오른쪽)의 구성도</p>\n<br>\n<p>우리에게 익숙한 <a href=\"http://www.vmware.com/\">VMware</a>나 <a href=\"https://www.virtualbox.org/\">VirtualBox</a>같은 가상머신은</p>\n<p>호스트 OS 위에 게스트 OS 전체를 가상화하여 사용하는 방식이다.</p>\n<p>이 방식은 무겁고 느려서 운영환경에선 사용하기 어려웠다.</p>\n<br>\n<p>이를 개선하기 위해 등장한 것이 <strong>컨테이너(Container)</strong> 방식이다.</p>\n<p>단순히 프로세스를 격리시키기 때문에</p>\n<p>호스트 OS에서 게스트 OS를 오가는 VM방식보다 가볍고 빠르게 동작한다.</p>\n<p>(어려운 말로 Context Switching의 Overhead가 적다!)</p>\n<br>\n<p>하나의 서버에 여러개의 컨테이너를 실행하면</p>\n<p>서로 영향을 미치지 않고 독립적으로 실행되어</p>\n<p>기존 VM과는 다르게 성능적으로도 거의 손실이 없다.</p>\n<p>(물론 네트워크 통신으로 인한 손실은 일부 있다!)</p>\n<br>\n<hr>\n<h2 id=\"도커의-작동방식\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EC%BB%A4%EC%9D%98-%EC%9E%91%EB%8F%99%EB%B0%A9%EC%8B%9D\" aria-label=\"도커의 작동방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도커의 작동방식</h2>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVQY03WRy27rMAxE/f+/l2QV4OI2beDUjiSKEinqRRZOgew6C2IwXJA4s9jfmkNbGb3OLqPLUD3COnsZTUYroy5mpqqmx9SpSnmmqBhnRgGKG4ePGL5S2tmmpcafeb/T85a3lf3CRULEAAiYUsQJoQPUfZucZXNzmjjfuRznWv8u/n9eP/JjZfcUXDBlTPl795gJfNBaqYgHNDPxqKYBE4t06TElrISFoZCvaS9xiSl7wNv94QCD89YasjyeXs2Ki2a6+4CUZ9NMjJzCv0RbcS0+S1wy8e7C/bHtPkCASVkisHeTqUGu1KPLjCK59TFS50iEhYKkqfMA1sf4WjcucsA73mUDby+So824Ernyy19f+7eWt9NXFUR0uVxO58vt9vkO30ZEzufz9Xo9nU4A8ANtDcxvkldrJAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-layer.png\"\n        title=\"image-layer.png\"\n        src=\"/static/5f06d8e9cb2fa58439ca928ef7594dd0/37523/2.png\"\n        srcset=\"/static/5f06d8e9cb2fa58439ca928ef7594dd0/e9ff0/2.png 180w,\n/static/5f06d8e9cb2fa58439ca928ef7594dd0/f21e7/2.png 360w,\n/static/5f06d8e9cb2fa58439ca928ef7594dd0/37523/2.png 720w,\n/static/5f06d8e9cb2fa58439ca928ef7594dd0/302a4/2.png 1080w,\n/static/5f06d8e9cb2fa58439ca928ef7594dd0/07a9c/2.png 1440w,\n/static/5f06d8e9cb2fa58439ca928ef7594dd0/8d7fa/2.png 1813w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>도커에서 가장 중요한 개념은 컨테이너와 <u>이미지(Image)</u>이다.</p>\n<p><u>이미지(Image)</u>는 <strong>컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 일종의 템플릿이다.</strong></p>\n<p>도커 이미지 자체는 시작하거나, 실행할 수 없다.</p>\n<p>컨테이너를 생성하면 불변 이미지(immutable image) 위에 쓰기 가능한 레이어가 추가되는 것뿐이다.</p>\n<p>즉, 프로그램과 프로세스의 차이처럼 컨테이너는 이미지를 실행한 상태라고 볼 수 있다.</p>\n<br>\n<p>이미지의 종류는 OS, DB, VCS, 라이브러리, 프레임워크, 언어 등 다양한 종류를 포함할 수 있다.</p>\n<p>이렇게 다양한 종류의 이미지를 레이어(Layer)라고 하여, 불변 이미지로써 조합하여 사용할 수 있다.</p>\n<p>Ubuntu + PostgreSql + Spring Boot의 조합을 담은 실행환경을 파일 하나로 공유하고 실행을 보증할 수 있다.</p>\n<br>\n<p>생각해보라.</p>\n<p>개발환경에서 설치하고, 환경변수를 세팅하고,</p>\n<p>의존성 추가 등 설치에 들어가는 시간과 비용을 줄일 수 있고, 1초만에 복제하고 확장할 수 있다.</p>\n<p>몇 기가짜리 파일을 계속 주고 받을 필요도 없다.</p>\n<br>\n<p>또한, Docker 위에 올라간 어플리케이션을 수정하면, 수정한 읽기/쓰기 레이어만 바꾸면 된다.</p>\n<p>Docker는 이미지 레이어를 그대로 사용하면서</p>\n<p>컨테이너가 실행중에 생성하는 파일이나 변경된 내용은</p>\n<p>읽기/쓰기 레이어에 저장되므로 여러개의 컨테이너를 생성해도 최소한의 용량만 사용한다.</p>\n<br>\n<hr>\n<h2 id=\"간단한-도커-설치\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98\" aria-label=\"간단한 도커 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 도커 설치</h2>\n<br>\n<p>도커 설치는 간단한 편이므로 운영체제에 맞게 짧고 빠르게 넘어가도록 하자.</p>\n<br>\n<h3 id=\"윈도우\" style=\"position:relative;\"><a href=\"#%EC%9C%88%EB%8F%84%EC%9A%B0\" aria-label=\"윈도우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>윈도우</strong></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACgUlEQVQ4y3VUyW7bMBDV9xbt1/QviqKn3tNrcwx6alI4duzIkiVSorhI3F4xI8uRHWSAwVAU+ebNxqI8HnE8HuGcw+QnpJRYc84Xu6xDCBeNMbL13sNai3EcWYv9fo+6rlFXNQN3XQcpJTrZoe97CCEghITWBiSLg0Vv94rm1KBpWmy3Wwbc7XaoqgpSCJxOJ3aglIJ1ji+nFWNaE1NaL8DFUY3487jBr7s7/L6/x8PDAzPWqsffx0cOS0qBtm1Rlq/sjJTOkDNaN03DUTHgoerwcqixfX5GWR755zAMcD6gGwzcFGAnz2pGsvM3/V+rMg4hJhR+8NCtxmtZMgtKLInzEZShmDIrh5dv7Hmf1KeMEDMKZy2ss9Bac94ojBAixpAuh1N6S/oClG8BY5oZjklDGapsx+yoBSjRxDCt2OkpsC6M12C0fgMcFZzTzGxpA6oah3xmR5ek9aiHiS9aP0dADqY4V5i+GRB+hO0abLc7zuHc2HlmeAakg9JMqHqHsndo9ARhPA6dw2mY0FmPSo0MXlitYPXAvUbVXXpKu4lBp5hZ1RjQO39RAiFLjoSZQUNKKNSUIJTG09MThJQMTKBkKa/WGuiVI+QEPfQI3iGGEaI9IaX41thEXY8TF2SZTxKjNVohuGE3mw2aVmARmsK5pWa7gJEU+EBE2zJjYzQOh1doPWCz2UO2fyBfvkAdPsOUnzDUX6/mubgd9sUTVZ0YUhvJruNXRUoFo0t01TdE8xOu+47tvx/XgO+5nQHPodJr5M7Ts8iggZiB0QNVPVwDxtX7tjQsjVD64HmaezMg54ic6K6/BqQ3j8LTSqG3HoOLkCbAx3yV7HU63sW02v8PzIx1heDmEUQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"관리자.png\"\n        title=\"관리자.png\"\n        src=\"/static/0feeb1e846a82fd75238507b0bbdc7eb/37523/3.png\"\n        srcset=\"/static/0feeb1e846a82fd75238507b0bbdc7eb/e9ff0/3.png 180w,\n/static/0feeb1e846a82fd75238507b0bbdc7eb/f21e7/3.png 360w,\n/static/0feeb1e846a82fd75238507b0bbdc7eb/37523/3.png 720w,\n/static/0feeb1e846a82fd75238507b0bbdc7eb/27b8e/3.png 836w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>방법1. Hyper-V를 이용하는 방법(간단)</p>\n<ol>\n<li>\n<p><strong>작업관리자 > 성능</strong>에서 가상화가 **‘사용’**으로 되어있는지 확인한다.</p>\n</li>\n<li>\n<p><strong>Window + S</strong>를 눌러 **‘Windows 기능’**을 검색 → <strong>Hyper-V</strong>를 체크하고 <strong>확인</strong>을 눌러 설치 → 재부팅</p>\n</li>\n</ol>\n<br>\n<p>방법2. WSL2를 이용하는 방법</p>\n<ol>\n<li>\n<p><strong>Windows 기능 켜기/끄기</strong>에서 <strong>Linux용 Windows 하위 시스템, 가상머신 플랫폼</strong>을 체크한다.</p>\n</li>\n<li>\n<p><strong>Linux 커널 업데이트 패키지 <a href=\"https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\">다운로드</a> 및 실행</strong></p>\n</li>\n<li>\n<p><strong>PowerShell에서 WSL 기본 버전을 2로 세팅한다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-default</span><span class=\"token operator\">-</span>version 2</code></pre></div>\n</li>\n</ol>\n<br>\n<p>방법1 or 2를 완료했다면 아래 링크에서 도커 설치파일을 다운로드 받고 실행하자</p>\n<p><a href=\"https://docs.docker.com/desktop/install/windows-install/\">Install Docker Desktop on Windows | Docker Documentation</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQoz62TwW7DIBBE+f+/69knS2lsYFMD3gVsS54KVOdErNTKSqPlwmMGFvV1dxi0hrYEYwlEBGstjDFIKTWVc0JeFsScIRLBLGBmCAtUTBnOOYxagx4/sERY1xVXS80xYZom3IcRw6gxaoOZGUtxEGN1FFPCtm11w77vp1KeY41YnBE9ai/wEAKc9whhhvehRnwC/3rrAJXyUl2wSHVUVNatOiCnkV/dVyvOO9An8AzwhrE28BN1GfjyUc4i/0cHQx3z9alSIlKH+KrKN/y+3dB1Hfq+xy/jy7C5rmpjkgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"중간에 나오는 WSL2 관련 옵션도 체크해주자\"\n        title=\"중간에 나오는 WSL2 관련 옵션도 체크해주자\"\n        src=\"/static/5e1fbf225b1c044de659cfd62f5fac23/37523/4.png\"\n        srcset=\"/static/5e1fbf225b1c044de659cfd62f5fac23/e9ff0/4.png 180w,\n/static/5e1fbf225b1c044de659cfd62f5fac23/f21e7/4.png 360w,\n/static/5e1fbf225b1c044de659cfd62f5fac23/37523/4.png 720w,\n/static/5e1fbf225b1c044de659cfd62f5fac23/b04e4/4.png 888w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>중간에 나오는 WSL2 관련 옵션도 체크해주자</strong></p>\n<br>\n<p>설치가 완료되면 <strong>Close and log out</strong>을 누르고 다시 윈도우에 로그인하고 약관에 동의하면 완료!</p>\n<br>\n<h3 id=\"리눅스\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4\" aria-label=\"리눅스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>리눅스</strong></h3>\n<p>리눅스의 설치는 아래 명령어를 통해 간단히 설치할 수 있다!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -fsSL https://get.docker.com/ <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> <span class=\"token function\">sh</span></code></pre></div>\n<br>\n<p>다음편에서는 IntelliJ에서 SpringBoot를 Docker 이미지로 배포해보도록 하자.</p>\n<br>\n<hr>\n<br>\n<p><em>출처</em></p>\n<p><em><a href=\"https://da2uns2.tistory.com/entry/Docker-%EB%8F%84%EC%BB%A4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-1-%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0\">[Docker] 도커 시작하기 - 1. 도커 설치하기 (tistory.com)</a></em></p>\n<p><em><a href=\"https://onu0624.tistory.com/102\">[Kubernetes] 쿠버네티스 윈도우에 설치하기 (Docker Desktop) (tistory.com)</a></em></p>\n<p><em><a href=\"https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html\">초보를 위한 도커 안내서 - 도커란 무엇인가? (subicura.com)</a></em></p>\n<br/>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%84%EC%BB%A4docker%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88container\"><strong>도커(Docker)와 컨테이너(Container)</strong></a></p>\n<ul>\n<li><a href=\"#%EB%8F%84%EC%BB%A4docker%EB%9E%80\"><strong>도커(Docker)란?</strong></a></li>\n<li><a href=\"#u%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88containeru%EB%9E%80\"><strong><u>컨테이너(Container)</u>란?</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EC%A1%B4-vmvirtual-machine%EA%B3%BC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EC%9D%BC%EA%B9%8C\"><strong>기존 VM(Virtual Machine)과 컨테이너는 무슨 차이일까?</strong></a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8F%84%EC%BB%A4%EC%9D%98-%EC%9E%91%EB%8F%99%EB%B0%A9%EC%8B%9D\">도커의 작동방식</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98\">간단한 도커 설치</a></p>\n<ul>\n<li><a href=\"#%EC%9C%88%EB%8F%84%EC%9A%B0\"><strong>윈도우</strong></a></li>\n<li><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4\"><strong>리눅스</strong></a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"지적과 댓글은 언제나 환영합니다! 이 글은 3편의 시리즈물로 제작하였다.  : Docker의 개념  : Spring Boot 앱을 Docker로 배포하기  : Docker 공식문서 같이읽기  시작해보자! 도커(Docker)와 컨테이너(Container) 도커(Docker)란? 도커는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너(Container)로 실행하고 관리하는 오픈소스 프로젝트이다. 컨테이너(Container)란? 컨테이너는 격리된 공간에서 프로세스가 작동하는 기술이다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 포함될 수 있다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다. 기존 VM(Virtual Machine)과 컨테이너는 무슨 차이일까?  VM(왼쪽)과 Docker(오른쪽)의 구성도 우리에게 익숙한 VMware나 VirtualBox같은 가상머신은 호스트 OS 위에 게스트 OS 전…","frontmatter":{"date":"October 24, 2022","title":"Let’s GO Docker(개념편)","categories":"infra","author":"주녁","emoji":"🔮"},"fields":{"slug":"/infra-learn-docker-basic-1/"}},"next":{"id":"0e7816c1-d9f3-5dc0-8463-5ec6afc408a8","html":"<p>지적과 댓글은 언제나 환영합니다!</p>\n<p><br/><br/></p>\n<h1 id=\"ddddomain-driven-design란\" style=\"position:relative;\"><a href=\"#ddddomain-driven-design%EB%9E%80\" aria-label=\"ddddomain driven design란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DDD(Domain Driven Design)란?</h1>\n<p><a href=\"hexagonal.png\">Hexagonal Architecture</a></p>\n<br>\n<p><a href=\"hexagonal2.png\">Hexagonal Architecture2</a></p>\n<br>\n<p>위 그림은 헥사고날 아키텍쳐(Hexagonal Architecture)로</p>\n<p>DDD를 적용한 아키텍쳐의 예시이다.</p>\n<p>역할과 책임을 아주 잘 분리한 깔끔한 설계라고 할 수 있다.</p>\n<br>\n<p>우리는 이러한 깔끔한 아키텍쳐 설계를 위한 도메인 주도 설계</p>\n<p>즉, DDD를 공부해볼 것이다.</p>\n<br>\n<p>크게 두 편으로 나누어 <code class=\"language-text\">개념</code> -> <code class=\"language-text\">예시</code> 순으로 진행할 것이다.</p>\n<p>DDD를 이야기하려면 Domain의 정의를 먼저 내려야 할 것이다.</p>\n<br/>\n<hr>\n<h2 id=\"ddd의-개념\" style=\"position:relative;\"><a href=\"#ddd%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\"ddd의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>DDD의 개념</strong></h2>\n<br>\n<ul>\n<li>\n<p>DDD란 비즈니스 도메인 별로 나눠서 설계하는 방식이다.</p>\n</li>\n<li>\n<p>비즈니스 도메인이란 유사한 업무의 집합을 말한다. (구매, 결제, 마케팅 등)</p>\n</li>\n<li>\n<p>DDD는 기존 IT 중심의 설계 → 현업과 쌍방향 설계를 추구하고자 생긴 개념이다.</p>\n</li>\n</ul>\n<br>\n<p>자, 아직까지는 DDD라는 개념이 크게 와닿지 않을 것이다.</p>\n<p>DDD를 쓰면 어떤 점이 좋길래 그렇게 권장하는 걸까?</p>\n<br>\n<hr>\n<h2 id=\"ddd가-해결할-수-있는-문제들\" style=\"position:relative;\"><a href=\"#ddd%EA%B0%80-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"ddd가 해결할 수 있는 문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>DDD가 해결할 수 있는 문제들</strong></h2>\n<br>\n<p>기존의 DB를 중심으로 아키텍쳐를 만드는 방식은 대부분 계층형 아키텍처이다.</p>\n<p>이러한 아키텍쳐는 DB가 속한 <code class=\"language-text\">영속성 계층</code>과 실제 서비스가 있는 <code class=\"language-text\">도메인 계층</code>에 강한 결합을 유도한다.</p>\n<p>즉, 특정 도메인에서만 쓸 수 있는 방법으로 DB를 조작하게 될 가능성이 높다.</p>\n<p>쉽게 말해, DB의 종류를 바꾸거나, 도메인을 Node.js에서 Spring으로 바꾼다면,</p>\n<p>프로젝트를 통째로 갈아엎어야 한다는 것이다.</p>\n<br>\n<p>엥? 그러면 안바꾸면 되는거 아니야?</p>\n<p>당장 내일 Node.js의 개발이 중단되어 망한 프로젝트가 된다면?</p>\n<p>DB를 추가할 때 다른 종류의 DB를 쓴다면?</p>\n<p>같은 코드를 처음부터 또 작성해야 한다.</p>\n<p>(<u>물론 항상 그렇다는 것은 아니다! 추상화를 잘하면 해결가능하다!</u>)</p>\n<br>\n<p>또한, 성능 측면에서 성능을 데이터베이스에 의존하게 된다.</p>\n<p>그리고 서비스는 단순히 속성값을 순서에 맞춰 저장해주는 스크립트 덩어리처럼 되어버린다.</p>\n<p>각각 상황별로 코드의 중복이 발생하고, 테스트도 중복되고 어려워진다.</p>\n<br>\n<p>DDD는 도메인의 비즈니스 로직을 기준으로 적절하게 응집시켜 놓았기 때문에</p>\n<p>거대한 서비스 클래스 대신 각각 단순한 역할만 하는 여러 클래스로 분산된다.</p>\n<p>따라서, 코드와 테스트의 중복을 최소화하고 재사용성을 높일 수 있다.</p>\n<br>\n<p>자, 이제 정의와 장점은 충분히 알았다.</p>\n<p>DDD의</p>\n<ul>\n<li>\n<p>DDD는 Strategic Design과 Tactical Design라는 두가지 단계로 나눌 수 있다.</p>\n</li>\n<li>\n<p>Strategic Design</p>\n<ul>\n<li>사용자의 상황에 맞게 설계하는 단계이다.</li>\n<li>때문에 단순 앱이나 사이트 그 이상, 제품 전체 경험을 중점으로 설계한다.</li>\n</ul>\n</li>\n<li>\n<p>Tactical Design</p>\n<ul>\n<li>Strategic Design에서 도출된 설계를 바탕으로 실행가능하도록 설계한다.</li>\n<li>실제 앱과 사이트를 실행하는 프로세스에 맞춰 설계한다.</li>\n<li>도메인을 서브도메인으로 쪼개서 정의한다.</li>\n<li>때문에 서브도메인도 문제로 재정의될 수 있다.(반복적이다)</li>\n</ul>\n</li>\n</ul>\n<br>\n<p>추상적인 이야기를 조금 더 구체화해서 소개하도록 하겠다.</p>\n<p>DDD는 어떻게 구성되는지 알아보자.</p>\n<hr>\n<h2 id=\"strategic-design-단계\" style=\"position:relative;\"><a href=\"#strategic-design-%EB%8B%A8%EA%B3%84\" aria-label=\"strategic design 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Strategic Design 단계</strong></h2>\n<br>\n<p>Strategic Design는 문제 영역(Problem Space)과 비즈니스 도메인을 분리하여 생각한다.</p>\n<p>Problem Space는 3가지로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">. Core Sub-Domain: 비즈니스 목적 달성을 위한 핵심 도메인\n\n. Supporting Sub-Domain: 핵심 도메인을 지원하는 도메인\n\n. Generic Subdomains:  공통 기능(메일, SSO 등) 도메인</code></pre></div>\n<br>\n<hr>\n<h2 id=\"tactical-design-단계\" style=\"position:relative;\"><a href=\"#tactical-design-%EB%8B%A8%EA%B3%84\" aria-label=\"tactical design 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Tactical Design 단계</strong></h2>\n<br>\n<p>Presentation, application, domain, infrastructure 계층으로 구분되어 있다.</p>\n<p>DDD의 핵심 목표는 모듈간의 의존성을 최소화하고 응집성은 최대화하는 것이다.\n하위 계층으로만 의존함으로서 구조가 복잡하여 발생할 수 있는 순환참조를 막을 수 있다.</p>\n<p>presentation → application → domain → infrastructure\n단방향으로 구성되어있기에 각 계층별 로직을 쉽게 이해할 수 있다.</p>\n<p>infrastructure는 domain의 추상화를 구현하는 계층으로 DIP의 활용을 극대화할 수 있다.</p>\n<h2 id=\"ddd의-예시\" style=\"position:relative;\"><a href=\"#ddd%EC%9D%98-%EC%98%88%EC%8B%9C\" aria-label=\"ddd의 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>DDD의 예시</strong></h2>\n<p><br/><br/></p>\n<h2 id=\"ddd는-꼭-써야할까\" style=\"position:relative;\"><a href=\"#ddd%EB%8A%94-%EA%BC%AD-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"ddd는 꼭 써야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>DDD는 꼭 써야할까?</strong></h2>\n<p>DDD 개념이 세간에 널리 알려지면서</p>\n<p>항상 정답인 것처럼 들릴 수 있겠지만,</p>\n<p>DDD는 어디에나 맞는 설계는 아니다.</p>\n<br>\n<p>그 이유는 비즈니스의 형태와 규모에 있다.</p>\n<p>내부용 서비스, 개인 블로그, 단순 조회성 서비스 등을 떠올려보라.</p>\n<p>그리고 다음 질문을 생각해보라.</p>\n<br>\n<ul>\n<li>\n<p>개발자가 기획자가 서로 도메인 지식을 알아야 할만큼 복잡한가?</p>\n</li>\n<li>\n<p>핵심 비즈니스 행위를 나누기 어려울만큼 비즈니스 로직이 단순한가?</p>\n</li>\n<li>\n<p>비즈니스를 확장하거나, 변경되지 않을 가능성이 높은가?</p>\n</li>\n</ul>\n<br>\n<p>블로그에 다양한 포트와 DB가 필요할까?</p>\n<p>1,000명 이하의 인원이 사용하는 내부용 ERP에서 도메인을 나눌만큼 복잡한 일이 있을까?</p>\n<br>\n<p>기존 Spring MVC 패턴에서 자주 보이는 다층 구조(Layered Architecture)도</p>\n<p>충분히 괜찮은 설계가 될 수 있다.</p>\n<p>결국, 상황에 맞는 적절한 패러다임을 선택하는 것이 중요하다.</p>\n<br>\n<p>다음 편에서는 실제 예시를 통해 DDD를 좀 더 자세하게 들여다보도록 하자.</p>\n<p><em>출처</em></p>\n<p>_<a href=\"https://vaadin.com/blog/ddd-part-1-strategic-domain-driven-design\">DDD Part 1: Strategic Domain-Driven Design</a></p>\n<p>_<a href=\"https://thedomaindrivendesign.io/what-is-strategic-design/\">What is Strategic Design ?</a></p>\n<p>_<a href=\"https://koreapy.tistory.com/1227\">koreapy님 블로그</a></p>\n<p><em><a href=\"https://kadensungbincho.tistory.com/73\">kadensungbincho님 블로그</a></em></p>\n<p><em><a href=\"https://happycloud-lee.tistory.com/94\">happycloud-lee님 블로그</a></em></p>\n<p><em><a href=\"https://blog.bespinglobal.com/post/domain-driven-design-1%EB%B6%80-strategic-design/\">베스핀글로벌 기술블로그 - Domain Driven Design – 1부 (Strategic Design)</a></em></p>\n<p><em><a href=\"https://blog.bespinglobal.com/post/domain-driven-design-2%eb%b6%80-tactical-design/\">베스핀글로벌 기술블로그 - Domain Driven Design – 2부 (Tactical Design)</a></em></p>\n<p><em><a href=\"https://yoonbing9.tistory.com/121\">yoonbing9님 블로그</a></em></p>\n<br/>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#ddd%EC%9D%98-%EA%B0%9C%EB%85%90\"><strong>DDD의 개념</strong></a></li>\n<li><a href=\"#ddd%EA%B0%80-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\"><strong>DDD가 해결할 수 있는 문제들</strong></a></li>\n<li><a href=\"#strategic-design-%EB%8B%A8%EA%B3%84\"><strong>Strategic Design 단계</strong></a></li>\n<li><a href=\"#tactical-design-%EB%8B%A8%EA%B3%84\"><strong>Tactical Design 단계</strong></a></li>\n<li><a href=\"#ddd%EC%9D%98-%EC%98%88%EC%8B%9C\"><strong>DDD의 예시</strong></a></li>\n<li><a href=\"#ddd%EB%8A%94-%EA%BC%AD-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\"><strong>DDD는 꼭 써야할까?</strong></a></li>\n</ul>\n</div>","frontmatter":{"date":"October 22, 2022","title":"DDD(Domain Driven Design)란 무엇일까? - (1)","categories":"knowledge","author":"주녁","emoji":"🔮"},"fields":{"slug":"/knowledge-about-DDD-1/포스팅 템플릿(학습)/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.junwork.net","comments":{"utterances":{"repo":"junwork123/blog-comments"}}}}},"pageContext":{"slug":"/infra-learn-docker-basic-1/","nextSlug":"/knowledge-about-DDD-1/포스팅 템플릿(학습)/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}